{-# LANGUAGE BangPatterns               #-}
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE DeriveFunctor              #-}
{-# LANGUAGE DeriveGeneric              #-}
{-# LANGUAGE ExplicitForAll             #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase                 #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE NoImplicitPrelude          #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE QuasiQuotes                #-}
{-# LANGUAGE RankNTypes                 #-}
{-# LANGUAGE ScopedTypeVariables        #-}
{-# LANGUAGE StandaloneDeriving         #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TupleSections              #-}
{-# LANGUAGE TypeApplications           #-}
{-# LANGUAGE TypeFamilies               #-}
{-# LANGUAGE TypeOperators              #-}
{-# LANGUAGE ViewPatterns               #-}

{-# OPTIONS_GHC -Wno-unused-imports -Wno-incomplete-patterns #-}

module Main where

import Refine.Frontend.Prelude

import qualified Data.ByteString.Lazy as LBS
import           Data.Char
import           Data.List
import qualified Data.Map as Map
import qualified Data.Set as Set
import qualified Data.Text as ST
import qualified Data.Text.IO as ST
import qualified Language.Css.Syntax as Css
import           System.Directory
import           System.Exit
import           System.FilePath
import           System.Process
import           Test.Hspec

import           React.Flux.Missing
import           Refine.Common.Color
import           Refine.Common.Test hiding (assert)
import           Refine.Common.Types
import           Refine.Frontend.Access
import           Refine.Frontend.Contribution.Bubble
import           Refine.Frontend.Contribution.Dialog
import           Refine.Frontend.Contribution.Types
import           Refine.Frontend.Document.FFI
import           Refine.Frontend.Document.Types
import           Refine.Frontend.Header.DiffToolbar
import           Refine.Frontend.Header.DiscussionToolbar
import           Refine.Frontend.Header.EditToolbar
import           Refine.Frontend.Header.Toolbar
import           Refine.Frontend.Header.Types
import           Refine.Frontend.Icon
import qualified Refine.Frontend.Icon.Svg as Svg
import           Refine.Frontend.Login.Component
import           Refine.Frontend.MainMenu.Component
import           Refine.Frontend.MainMenu.Types
import           Refine.Frontend.Screen.Types
import           Refine.Frontend.Store
import           Refine.Frontend.Store.Types
import           Refine.Frontend.Test.Enzyme hiding (Prop)
import           Refine.Frontend.Util
import           Refine.Frontend.Views


-- * config

styleGuidePath :: FilePath
styleGuidePath = "./styleguide/html/"


-- * colors

colorCssVarDecl :: Color -> ST
colorCssVarDecl c = mconcat
  ["$", colorName ColorAttrDefault c, ": ", showRGBA $ colorValue c, ";"]

colorCssClassDecl :: ColorAttr -> Color -> ST
colorCssClassDecl attr c = mconcat
  [".", colorName attr c, " { ", showAttr attr, ": $", colorName ColorAttrDefault c, " }"]
  where
    showAttr ColorAttrDefault         = "color"
    showAttr ColorAttrBackgroundColor = "background-color"
    showAttr ColorAttrFill            = "fill"

colorCssFile :: ST
colorCssFile = ST.unlines $ header <> (kinds <*> [minBound ..])
  where
    kinds = colorCssVarDecl : (colorCssClassDecl <$> [minBound..])
    header =
      [ "// this file is auto-generated by the `styleguide` test suite."
      , "// you can edit it, but you need to carry the changes over to `../styleguide/Main.hs`."
      , ""
      ]

colorHtmlFile :: ST
colorHtmlFile = ST.unlines $ header <> mconcat (go <$> [minBound ..]) <> footer
  where
    title = "Color Palette"
    header =
      [ "<!doctype html>"
      , "<html>"
      , "<head>"
      , "<meta charset=\"UTF_8\">"
      , "<title>" <> title <> "</title>"
      , "<link href=\"../../scss-new/main.css\" rel=\"stylesheet\" type=\"text/css\">"
      , "<style>"
      , "  body{font-family: 'Source Sans Pro', sans-serif; font-weight: 300; font-size: 14px;}"
      , "  .black{font-weight: 800;}"
      , "  .container{"
      , "    position: relative;"
      , "    clear: both;"
      , "    height: 120px;"
      , "  }"
      , "  .color{"
      , "    width: 60px;"
      , "    height: 120px;"
      , "    float: left;"
      , "    margin-right: 10px;"
      , "  }"
      , "  .description{"
      , "    padding-top: 12px;"
      , "  }"
      , "  h1, h2{font-weight: 300;}"
      , "</style>"
      , "</head>"
      , ""
      , "<body>"
      , "<h1>" <> title <> "</h1>"
      ]
    footer =
      [ "</body>"
      , "</html>"
      ]

    go :: Color -> [ST]
    go color =
      [ "<div class=\"container\">"
      , "  <div class=\"color " <> colorName ColorAttrBackgroundColor color <> "\">"
      , "  </div>"
      , "  <div class=\"description\">"
      , "    Variable:&nbsp;&nbsp;<span class=\"black\">$" <> colorName ColorAttrDefault color <> "</span><br>"
      , "    Class (color):&nbsp;&nbsp;<span class=\"black\">" <> colorName ColorAttrDefault color <> "</span><br>"
      , "    Class (background-color):&nbsp;&nbsp;<span class=\"black\">" <> colorName ColorAttrBackgroundColor color <> "</span><br>"
      , "    Color:&nbsp;&nbsp;<span class=\"black\">" <> showRGBA (colorValue color) <> "</span><br>"
      , "  </div>"
      , "</div>"
      , "<br>"
      ]

colorPalette :: Spec
colorPalette = it "colorPalette" $ do
  ST.writeFile "./scss-new/20-colors.scss" colorCssFile
  ST.writeFile (styleGuidePath <> "colorPalette.html") colorHtmlFile


-- * combinators

clearHtml :: Spec
clearHtml = it "remove old html code" $ do
  (_, filter ((== ".html") . takeExtension) . lines -> vcfiles, "")
      <- readProcessWithExitCode "/usr/bin/git" ["grep", "-l", ".", styleGuidePath] mempty
  (_, _, _)
      <- readProcessWithExitCode "/bin/rm" vcfiles mempty
  pure ()

wrapHtml :: FilePath -> [String] -> String -> String
wrapHtml nm ctx = (unlines header <>) . (<> unlines footer)
  where
    cssSource :: FilePath = relPath </> "main.css"
    relPath :: FilePath = assert (not $ "./" `isInfixOf` nm)  -- (without this assertion this hack won't work)
      . mconcat
      $ replicate (length $ filter (== '/') nm) "../"

    header =
      "<!DOCTYPE html>" :
      "<html>" :
      "<head>" :
      "  <meta charset=\"utf-8\">" :
      "  <title>liqlua style guide</title>" :
      "  <link rel=\"stylesheet\" media=\"all\" href=\"" <> cssSource <> "\" />" :
      "</head>" :
      "<body>" :
      ["  <div class=\"" <> unwords ctx <> "\">" | not $ null ctx]

    footer =
      ["  </div>" | not $ null ctx] <>
      ("</body>" :
      "</html>" :
      [])

-- | Run a haskell view and store the generated html in a file.
generateStyleGuide :: HasCallStack => (String, IO (ReactElementM h ()), [String]) -> Spec
generateStyleGuide (nm, comp, ctx) = it ("generateStyleGuide: " <> nm) $ do
  createDirectoryIfMissing True (styleGuidePath <> takeDirectory nm)
  writeFile (styleGuidePath <> nm <> ".html") . wrapHtml nm ctx . cs =<< html =<< mount =<< comp

generateIndexHtml :: HasCallStack => Spec
generateIndexHtml = it "generateIndexHtml" $ do
  nms <- viewsFiles
  writeFile (styleGuidePath <> "index.html") . unlines $
    ["<!DOCTYPE html><html><body>"] <>
    ((\nm -> "<a href=\"" <> nm <> "\">" <> nm <> "</a><br/>") <$> nms) <>
    ["<br><hr><br><a href=\"colorPalette.html\">colorPalette.html</a>"] <>
    ["</body></html>"]

-- | Pretty-print, canonicalize, validate existing html.  This is called in the tests after
-- 'generateStyleGuide', and should also be called before and after manual edit to supress diff
-- noise.
--
-- FUTUREWORK: use `apt-get install w3c-markup-validator` to get more html errors?  it's an ugly cgi
-- script and may not be fun to deploy, but it may be well-maintained.
validateStyleGuide :: HasCallStack => Spec
validateStyleGuide = it "validateStyleGuide" $ viewsFiles >>= mapM_ (val . (styleGuidePath <>))
  where
    val  nm = do
      raw <- pretty nm =<< readFile nm
      force raw `seq` writeFile nm raw

    force s = case cs s of ((>0) . ST.length -> True) -> s

-- | use tidy(1) to do html pretty-printing and sanity checking.
--
-- Rationale: HaXml breaks the HTML tree!  (it turns siblings into ancestors / descendants) hxt does not
-- have a pretty-printer.  the other options are confusing and un-promising for the task at hand.
-- also, we may want to use other tools for html sanity checking here that are not available on
-- hackage.
pretty :: String -> String -> IO String
pretty nm content = do
  -- NOTE: 'system' has dynamic type errors in ghcjs/node!
  -- NOTE: 'rawSystem' can be called, but if tidy is not installed it triggers a js exception that
  -- cannot be caught here, so the following test is not producing the nice error message that i
  -- hoped.
  -- void (rawSystem "/usr/bin/tidy" []) `catch`
  --   \(SomeException msg) -> error $ show msg <> "\n\n*** try `apt-get install tidy`?\n\n"

  (code, o, e) <- readProcessWithExitCode "/usr/bin/tidy" ["--tidy-mark", "no", "-i"] content
  let err msg = error $ "pretty " <> msg <> ": "     <> show (nm, code, o, e)
  case code of
    ExitSuccess   -> pure o
    ExitFailure 1 -> pure o  -- (call @err "warnings"@ here?)
    ExitFailure 2 -> err "errors"
    ExitFailure _ -> err "UNEXPECTED"

-- | Make sure the style guide working copy contains no changes wrt. the last commit.  Run this
-- after generating content to make sure the the haskell code is in sync with the style guide.
checkWorkingCopy :: HasCallStack => Spec
checkWorkingCopy = it "checkWorkingCopy" $ do
  filter isDirty <$> gitStatus `shouldReturn` []


-- * sample content

toy_ :: forall h. ReactElementM h ()
toy_ = div_ [style [ "margin" ||= Css.Px 10
                   , "border" ||= Css.Px 2
                   , "border" ||= [Css.Ident "dashed", Css.Ident "black"]
                   ]
            ] $ do
  div_ [style (box "red")] $ do
    div_ [style (box "blue")] mempty
    div_ [style (box "blue")] mempty
    div_ [style (box "blue")] $ do
      div_ [style (box "red")] mempty
      div_ [style (box "red")] mempty
      div_ [style (box "red")] mempty
    div_ [style (box "green")] mempty
    div_ [style (box "gray")] mempty
  div_ [style (box "gray")] mempty
  div_ [style (box "gray")] mempty
  div_ [style (box "gray")] mempty

  where
    box :: String -> [Css.Decl]
    box bg =
      [ "border" ||= [Css.Ident "dashed", Css.Ident "black", Css.Ident "2px"]
      , "padding" ||= Css.Px 50
      , "margin" ||= Css.Px 60
      , "width" ||= Css.Px 70
      , "height" ||= Css.Px 70
      , "backgroundColor" ||= Css.Ident bg
      ]


-- * production content

-- | NOTE: listDirectory throws a `("setErrno not yet implemented: " + e);`, so we just take
-- `viewsSources`' word for it.
viewsFiles :: IO [FilePath]
viewsFiles = pure $ (<> ".html") . view _1 <$> viewsSources
  -- (styleGuidePath <>) <$$> listDirectoryRec styleGuidePath


importTestData :: FromJSON a => FilePath -> IO a
importTestData fp = do
  lbs <- LBS.readFile $ styleGuidePath <> fp
  case eitherDecode lbs of
    Right v -> pure v
    Left msg -> throwIO . ErrorCall $ show ("importTestDataIO: " <> fp, msg)

-- | FIXME: access state and global state should also be loaded into the stores.  at least access
-- state will be pulled by every access guard.
runWholeScreen :: Maybe FilePath -> Maybe FilePath -> Maybe (GlobalState -> GlobalState) -> IO (ReactElementM h ())
runWholeScreen asfp gsfp fixgs = do
  as <- maybe (pure emptyAccessState) (importTestData @AccessState) asfp
  gs <- maybe (pure emptyGlobalState) (importTestData @GlobalState) gsfp
  rc <- pure . createWithRawContent $ (gs ^. gsRawContent) & rawContentBlocks %~ initBlockKeys
  -- () <- traceShow (as, gs, rc) $ pure ()
  mapM_ executeAction . dispatch @EditorStoreAction $ UpdateEditorStore rc
  pure $ wholeScreen_ as (fromMaybe id fixgs gs)


viewsSources :: [(String, IO (ReactElementM 'EventHandlerCode ()), [String])]
viewsSources =
    [ ("toy_", pure toy_, ["testclass"])

    , ("wholeScreen_/empty-empty", runWholeScreen Nothing Nothing Nothing, [])

    , ("wholeScreen_/empty-login", runWholeScreen Nothing (Just "wholeScreen_/empty-login.GlobalState.json") Nothing, [])
    , let act = runWholeScreen (Just "wholeScreen_/empty-iamadmin.AccessState.json")
                                (Just "wholeScreen_/empty-iamadmin.GlobalState.json")
                                Nothing
      in ("wholeScreen_/empty-iamadmin", act, [])

    , let act = runWholeScreen (Just "wholeScreen_/creategroup.AccessState.json")
                                (Just "wholeScreen_/creategroup.GlobalState.json")
                                (Just $ gsPageState .~ PageStateMainMenu (MainMenuState
                                                (MainMenuProfile (1, newLocalStateRef ((Nothing, Nothing) :: ProfileLocalState) act))
                                                (MainMenuErrors Nothing Nothing))
                                               Nothing)
      in ("wholeScreen_/profile-iamadmin", act, [])

    , let act = runWholeScreen (Just "wholeScreen_/creategroup.AccessState.json")
                                (Just "wholeScreen_/creategroup.GlobalState.json")
                                (Just $ gsPageState .~ PageStateMainMenu (MainMenuState
                                                (MainMenuCreateOrUpdateGroup Nothing (newLocalStateRef sampleCreateGroup act))
                                                (MainMenuErrors Nothing Nothing))
                                               Nothing)
      in ("wholeScreen_/creategroup", act, [])

    , let act = runWholeScreen (Just "wholeScreen_/createprocess.AccessState.json")
                                (Just "wholeScreen_/createprocess.GlobalState.json")
                                (Just $ gsPageState .~ PageStateMainMenu (MainMenuState
                                                (MainMenuCreateProcess (newLocalStateRef sampleCreateVDoc act))
                                                (MainMenuErrors Nothing Nothing))
                                               Nothing)
      in ("wholeScreen_/createprocess", act, [])

{- FIXME: these need to be re-generated

      -- TODO: if i run this test case after the next one (view-vdoc), i get a runtime crash
      -- (something about inconsistent dom?).
    , let act = runWholeScreen (Just "wholeScreen_/view-discussion.AccessState.json")
                                (Just "wholeScreen_/view-discussion.GlobalState.json")
                                Nothing
      in ("wholeScreen_/view-discussion", act, [])

    , let act = runWholeScreen (Just "wholeScreen_/view-vdoc.AccessState.json")
                                (Just "wholeScreen_/view-vdoc.GlobalState.json")
                                Nothing
      in ("wholeScreen_/view-vdoc", act, [])
-}

    , ("menu/login_", pure $ login_ Nothing, [])
    , ("menu/mainMenuGroups_", pure $ view_ mainMenuGroups "mainMenuGroups"
        ( GroupsProps
            [sampleGroup1, sampleGroup2]
            (Map.singleton (ID 0) sampleVDoc)
            (mkUserMap [ User sampleMetaID "user" "<email@bla.com>" Nothing ""
                       , User sampleMetaID "üsör" "<grr@bla.com>" Nothing "" & userID .~ ID 8479])
        ), [])
    , ("menu/mainMenuGroup_", pure $ view_ mainMenuGroup "mainMenuGroup"
        ( MainMenuGroupProcesses
        , GroupProps
            (Just sampleGroup1)
            (Map.singleton (ID 0) sampleVDoc)
            (mkUserMap [ User sampleMetaID "user" "<email@bla.com>" Nothing ""
                       , User sampleMetaID "üsör" "<grr@bla.com>" Nothing "" & userID .~ ID 8479])
        ), [])
    -- , ("mainMenuCreateGroup_", mainMenuCreateGroup_ _, [])
    -- , ("mainMenuCreateProcess_", mainMenuCreateProcess_ _, [])

    , ("toolbar/toolbar_", pure $ toolbar_ sampleVDoc, [])
    , ("toolbar/editToolbar_", pure . editToolbar_ $ EditToolbarProps EditIsNotInitial, [])
    , ("toolbar/diffToolbar_", pure $ diffToolbar_ DiffToolbarProps
        { _diffToolbarPropsEditID = ID 0
        , _diffToolbarIndex       = EditIndex 1 3
        , _diffToolbarEditKind    = Meaning
        , _diffToolbarPropsVotes  = mempty
        , _diffToolbarCollapsed   = False
        , _diffToolbarEditable    = False
        }, [])
    , ("toolbar/discussionToolbar_.flat", pure . discussionToolbar_ $ DiscussionToolbarProps (Just $ ID 0) True False mempty, [])
    , ("toolbar/discussionToolbar_.tree", pure . discussionToolbar_ $ DiscussionToolbarProps (Just $ ID 0) False False mempty, [])

    , ("bubble_.edit", pure $ bubble_ BubbleProps
        { _bubblePropsContributionIds   = NoStack (ContribIDEdit (ID 0), 0)
        , _bubblePropsIconSide          = BubbleRight
        , _bubblePropsVerticalOffset    = Nothing
        , _bubblePropsHighlight         = False
        , _bubblePropsScreenState       = ScreenState 0 0 Desktop
        } (elemText "lorem ipsum"), [])

    , ("bubble_.discussion.active.desktop", pure $ bubble_ BubbleProps
        { _bubblePropsContributionIds   = NoStack (ContribIDDiscussion False (ID 0), 0)
        , _bubblePropsIconSide          = BubbleLeft
        , _bubblePropsVerticalOffset    = Nothing
        , _bubblePropsHighlight         = True
        , _bubblePropsScreenState       = ScreenState 0 0 Desktop
        } (elemText "lorem ipsum"), [])

    , ("bubble_.discussion.active.mobile", pure $ bubble_ BubbleProps
        { _bubblePropsContributionIds   = NoStack (ContribIDDiscussion False (ID 0), 0)
        , _bubblePropsIconSide          = BubbleLeft
        , _bubblePropsVerticalOffset    = Nothing
        , _bubblePropsHighlight         = True
        , _bubblePropsScreenState       = ScreenState 0 0 Mobile
        } (elemText "lorem ipsum"), [])

    , ("bubble_.stack", pure $ bubble_ BubbleProps
        { _bubblePropsContributionIds   = Stack ((ContribIDEdit (ID 0), 0) :| [(ContribIDEdit (ID 0), 0)])
        , _bubblePropsIconSide          = BubbleLeft
        , _bubblePropsVerticalOffset    = Nothing
        , _bubblePropsHighlight         = False
        , _bubblePropsScreenState       = ScreenState 0 0 Desktop
        } (elemText "lorem ipsum"), [])

    , ("addEdit_", pure $ addEdit_ AddContributionProps
        { _acpRange         = Nothing
        , _acpLocalState    = let info = EditInfo "this is what i did" (Just Grammar)
                                           (newLocalStateRef st '3')
                                  st = EditInputState info [(Grammar, ButtonState Svg.Pressed Svg.NotRollOver)]
                              in (info, createEmpty)
        , _acpWindowWidth   = 1600
        }, [])
    ]
  where
    mkUserMap = Map.fromList . map ((^. userID) &&& id)


-- * git (cloned from `/scripts/style-check.hs`)

data GitStatus = GitStatus GitStatusCode GitStatusCode FilePath
  deriving (Eq, Show, Ord)

data GitStatusCode =
    Unmodified
  | Modified
  | Added
  | Deleted
  | Renamed
  | Copied
  | UpdatedButUnmerged
  | Untracked
  | Ignored
  deriving (Eq, Show, Ord)

isDirty :: GitStatus -> Bool
isDirty (GitStatus _ Ignored _)   = False
isDirty _                         = True

gitStatus :: IO [GitStatus]
gitStatus = do
  (code, o, e) <- readProcessWithExitCode "/usr/bin/git" ["status", "--porcelain", styleGuidePath] ""
  case code of
    ExitSuccess -> pure . fmap prse . ST.lines . cs $ o
    _ -> error $ "gitStatus: " <> show (code, o, e)
  where
    prse :: ST -> GitStatus
    prse line = GitStatus (parseCode ix_) (parseCode wt_) (cs file_)
      where
        ix_   = ST.take 1               line
        wt_   = ST.take 1 . ST.drop 1 $ line
        file_ =             ST.drop 3   line

    parseCode :: ST -> GitStatusCode
    parseCode " " = Unmodified
    parseCode "M" = Modified
    parseCode "A" = Added
    parseCode "D" = Deleted
    parseCode "R" = Renamed
    parseCode "C" = Copied
    parseCode "U" = UpdatedButUnmerged
    parseCode "?" = Untracked
    parseCode "!" = Ignored
    parseCode bad = error $ "gitStatus: could not parse status code " <> show bad


-- * main

main :: IO ()
main = do
  registerInitialStore emptyGlobalState
  registerInitialStore emptyAccessState
  registerInitialStore emptyEditorStore
  initRouting
  hspec spec

spec :: Spec
spec = describe "@STYLEGUIDE" $ do
    describe "clearHtml"      clearHtml
    describe "color palette"  colorPalette
    describe "generate views" (generateStyleGuide `mapM_` viewsSources)
    describe "generate index" generateIndexHtml
    describe "validate"       (validateStyleGuide >> checkWorkingCopy)
