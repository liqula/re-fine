#!/usr/bin/env stack
{- stack --resolver lts-7.15 --install-ghc runghc
    --package foldl
    --package regex-posix
    --package string-conversions
    --package system-filepath
    --package turtle

    --

    -XBangPatterns
    -XDeriveDataTypeable
    -XExistentialQuantification
    -XGeneralizedNewtypeDeriving
    -XLambdaCase
    -XNoImplicitPrelude
    -XOverloadedStrings
    -XPackageImports
    -XRecordWildCards
    -XScopedTypeVariables
    -XStandaloneDeriving
    -XTupleSections
    -XViewPatterns

    -Wall

-}

import           Control.Exception (assert)
import qualified Control.Foldl as Fold
import           Data.List (foldl', sort)
import           Data.Map (Map)
import qualified Data.Map as Map
import           Data.String.Conversions
import qualified Data.Text as ST
import qualified Data.Text.IO as ST
import           Filesystem.Path.CurrentOS
import           Prelude hiding (FilePath)
import           System.Environment
import           System.Exit
import           Text.Read (readMaybe)
import           Text.Regex.Posix
import           Turtle hiding (f)


usage :: ExitCode -> IO ()
usage exitCode = do
  pname <- getProgName
  putStrLn $ unlines
    [ unwords ["usage:", pname, "<source_tree>", "<trans_module_path>", "<trans_module_name>", "<po*_path>"]
    , ""
    , "Generates \"*.Trans\" modules and PO, POT files for internationalization.  The purpose of the"
    , "\"*.Trans\" modules is to make it explicit what language keys we have, which should make"
    , "it harder to introduce spelling errors."
    , ""
    , "<source_tree> can be any sub-tree of the target code base, including the entire code base."
    , "To keep things simple, <trans_module_path>, <trans_module_name> both have to be specified"
    , "somewhat redundantly (example: src/Frontend/Views.hs and Frontend.Views), and <po*_file>"
    , "must be absolute paths."
    , ""
    , "Existing PO files under <po*_path> will be updated (new t-keys added with empty translation,"
    , "unused ones removed)."
    , ""
    , "Note that updating PO files is only guaranteed to work on PO files generated by this script."
    , "When translating, best not to change anything outside of the translation texts!"
    ]
  exitWith exitCode


transModDeps :: [ST]
transModDeps = ["Refine.Common.Types.Translation", "Data.Text"]


main :: IO ()
main = do
  unitTestMatchTKeys
  args <- getArgs
  case args of
    [sourceTree, transModuleFile, transModuleName, poDir]
      -> main' (fromString sourceTree) (fromString transModuleFile) (cs transModuleName) (fromString poDir)
    _ -> usage $ ExitFailure 1


main' :: FilePath -> FilePath -> ST -> FilePath -> IO ()
main' sourceTree transModuleFile transModuleName poDir = do
  sourceFiles <- filter ((== Just "hs") . extension) <$> (lstree sourceTree `fold` Fold.list)
  tKeyCalls   <- mkTKeyCalls . mconcat <$> (getTKeyCallsIO `mapM` sourceFiles)
  ST.writeFile (encodeString transModuleFile) $ createTransModule transModuleName tKeyCalls
  ST.writeFile (encodeString $ poDir </> "template.pot") $ createPotFile tKeyCalls
  updatePoFilesIO poDir tKeyCalls


-- * collect

data TKeyCall = TKeyCall FilePath Int ST
  deriving (Eq, Show)

getTKeyCallsIO :: FilePath -> IO [TKeyCall]
getTKeyCallsIO filepath = getTKeyCalls filepath <$> ST.readFile (encodeString filepath)

getTKeyCalls :: FilePath -> ST -> [TKeyCall]
getTKeyCalls filepath = mconcat . fmap (uncurry go) . zip [1..] . ST.lines
  where
    go :: Int -> ST -> [TKeyCall]
    go num line = TKeyCall filepath num . cs <$> matchTKeys (cs line)

matchTKeys :: SBS -> [SBS]
matchTKeys line = case mrSubList res of
  []    -> []
  [key] -> key : matchTKeys (mrAfter res)
  bad   -> error $ "getTKeyCalls: impossible regex match: " <> show bad
  where
    res :: MatchResult SBS
    res = line =~ ("\\(__ ([^\\)]+)\\)" :: SBS)

unitTestMatchTKeys :: IO ()
unitTestMatchTKeys = assert (and tests) (pure ())
  where
    tests =
      [ matchTKeys "(__ some_keyIWU)" == ["some_keyIWU"]
      , matchTKeys "..  (__ some_keyIWU) .. (__ WER) ..." == ["some_keyIWU", "WER"]
      ]


-- * generate

type TKeyCalls = Map ST [(FilePath, Int)]
type TKeyCallsWithTrans = Map ST ([(FilePath, Int)], ST)

mkTKeyCalls :: [TKeyCall] -> TKeyCalls
mkTKeyCalls = foldl' go mempty
  where
    go m (TKeyCall sp sl key) = Map.alter (alt (sp, sl)) key m
    alt loc = Just . maybe [loc] (loc:)

createTransModule :: ST -> TKeyCalls -> ST
createTransModule name tKeyCalls = ST.unlines $
    ["module " <> name <> " where", ""] <>
    (("import " <>) <$> transModDeps) <> [""] <>
    ["{-# ANN module \"HLint: ignore Use camelCase\" #-}", ""] <>
    (go <$> Map.keys tKeyCalls)
  where
    go key = ST.unlines
      [ key <> " :: TKey"
      , key <> " = TKey $ pack \"" <> key <> "\""
      ]

createPotFile :: TKeyCalls -> ST
createPotFile = createPoFile . ((, "") <$>)


updatePoFilesIO :: FilePath -> TKeyCalls -> IO ()
updatePoFilesIO poDir tKeyCalls =
  mapM_ (`updatePoFileIO` tKeyCalls) . filter ((== Just "po") . extension) =<< (lstree poDir `fold` Fold.list)

updatePoFileIO :: FilePath -> TKeyCalls -> IO ()
updatePoFileIO (encodeString -> poFile) tKeyCalls = do
  !poContent <- (`updatePoFile` tKeyCalls) <$> ST.readFile poFile
  ST.writeFile poFile poContent

updatePoFile :: ST -> TKeyCalls -> ST
updatePoFile poContent tKeyCalls = createPoFile . merge tKeyCalls . readPoFile $ poContent
  where
    merge :: TKeyCalls -> TKeyCallsWithTrans -> TKeyCallsWithTrans
    merge clls trns = addTrans `Map.mapWithKey` clls
      where
        addTrans :: ST -> [(FilePath, Int)] -> ([(FilePath, Int)], ST)
        addTrans tkey loc = (loc, maybe "###" snd (Map.lookup tkey trns))

readPoFile :: ST -> TKeyCallsWithTrans
readPoFile = s0 . ST.lines
  where
    s0 :: [ST] -> TKeyCallsWithTrans
    s0 ("" : lns) = s0 lns
    s0 lns        = s1 [] lns

    s1 :: [(FilePath, Int)] -> [ST] -> TKeyCallsWithTrans
    s1 locs (ln : lns) = if "#: " `ST.isPrefixOf` ln
      then s1 (parseLoc ln : locs) lns
      else s2 (reverse locs) (ln : lns)
    s1 [] [] = mempty
    s1 (_:_) [] = error "readPoFile: parse error (file ends with source locations)."

    s2 :: [(FilePath, Int)] -> [ST] -> TKeyCallsWithTrans
    s2 locs ((ST.splitAt 6 -> ("msgid ", readMaybe . cs -> Just tkey)) : lns) = s3 (locs, tkey) lns
    s2 _ _ = error "readPoFile: parse error (file ends with broken/incomplete entry at msgid)."

    s3 :: ([(FilePath, Int)], ST) -> [ST] -> TKeyCallsWithTrans
    s3 (locs, key) ((ST.splitAt 7 -> ("msgstr ", readMaybe . cs -> Just trans)) : lns) =
        Map.insert key (locs, trans) $ s0 lns
    s3 _ _ = error "readPoFile: parse error (file ends with broken/incomplete entry at msgstr)."

parseLoc :: ST -> (FilePath, Int)
parseLoc line = case mrSubList ((cs line :: SBS) =~ ("^#: (.+):(.+)$" :: SBS) :: MatchResult SBS) of
  [fromString . cs -> sourceFile, read . cs -> sourceLine] -> (sourceFile, sourceLine)
  bad   -> error $ "parseLoc: parse error: " <> show (line, bad)

createPoFile :: TKeyCallsWithTrans -> ST
createPoFile = ST.unlines . fmap go . Map.toAscList
  where
    go :: (ST, ([(FilePath, Int)], ST)) -> ST
    go (key, (locs, trans)) = ST.unlines $ (showLoc <$> sort locs) <>
      [ "msgid \"" <> key <> "\""
      , "msgstr " <> (cs . show $ trans)  -- (not fast, but escapes '"'.)
      ]

    showLoc :: (FilePath, Int) -> ST
    showLoc (sourcePath, sourceLine) = cs $ "#: " <> encodeString sourcePath <> ":" <> show sourceLine
